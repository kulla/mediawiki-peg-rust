use ast::*;

#![arguments(source_lines: &Vec<SourceLine>)]

/** the main document structure */
pub Document -> Element 
    = posl:#position top:Paragraph* content:Heading* posr:#position {
        let mut res = top;
        let mut content = content;
        res.append(&mut content);
 
        Element::Document {
            position: Span::new(posl, posr, source_lines),
            content: res, 
        }
}

/** all paragraphs after a heading belong to its content */
HeadingParagraph -> Element 
    = ParagraphTemplate<FormattedTextTemplate<Text<HeadingChar>>>

/** A heading is a caption paragraph followed by content paragraphs. */
Heading -> Element 
    = posl:#position d:$("="+) Space* caption:HeadingParagraph "="* pars:Paragraph* posr:#position {
        Element::Heading {
            position: Span::new(posl, posr, source_lines),
            depth: d.len(),
            caption: Box::new(caption),
            content: pars,
        }
    }

/**
 * a paragraph is a block element, some or no text followed by a newline or just some text.
 * The FormattedRule parameter is only applied to plain top-level text. All nested formatting
 * uses the standart FormattedText rule. This keeps formatted text or html tags from beeing
 * ripped apart.
 */
ParagraphTemplate<FormattedRule> 
    = List / Table / posl:#position PAR_START_GUARD text:(
        (t:FormattedRule* Newline {t}) / (f:FormattedRule+ Newline? {f})
      ) posr:#position {
       
         Element::Paragraph {
            position: Span::new(posl, posr, source_lines),
            content: text,
        }
    } 

/**
 *  the standard paragraph 
 */
Paragraph -> Element
    = ParagraphTemplate<FormattedText>


/*
 *Template parsing
 */
TemplateParagraph -> Element
    = ParagraphTemplate<FormattedTextTemplate<Text<TemplateContentChar>>>

/** 
 * mediawiki templates have a name followed by a sequence of arguments 
 */
Template -> Element 
    = posl:#position "{{" Space* n:TemplateName (Space / Newline)* attrs:("|" t:TemplateArgument {t})* "}}" posr:#position {
        
        Element::Template {
            position: Span::new(posl, posr, source_lines),
            name: n,
            content: attrs
        }
    }

TemplateArgument -> Element
    = posl:#position name:(n:TemplateArgumentName "=" {n})? value:TemplateParagraph+ posr:#position {
     
       Element::TemplateArgument {
            position: Span::new(posl, posr, source_lines),
            name: name.unwrap_or(String::new()),
            value: value,
        }    
    } 


/*
 mediawiki lists
 */
List -> Element
    = posl:#position items:ListItem+ Space* Newline? posr:#position {
        Element::List {
            position: Span::new(posl, posr, source_lines),
            content: items,
        }
    }

ListItem -> Element
    = Space* posl:#position s:($("*" / "#" / ":" / ";"))+ Space* content:FormattedText* Newline? posr:#position {
    
        let kind = match s[s.len() - 1] {
            "*" => ListItemKind::Unordered,
            "#" => ListItemKind::Ordered,
            ":" => ListItemKind::Definition,
            ";" => ListItemKind::DefinitionTerm,
            _ => ListItemKind::Unordered,
        };

        Element::ListItem {
            position: Span::new(posl, posr, source_lines),
            depth: s.len(),
            kind: kind,
            content: content,
        }
    }

/*
 mediawiki tables
 */
Table -> Element
    = posl:#position "{|" attr:TableElementAttributes? (Space / Newline)* caption:TableCaption? rows:TableRow* "|}" posr:#position { 
    
        let (cap_attrs, cap_pars) = caption.unwrap_or((vec![], vec![]));

        Element::Table {
            position: Span::new(posl, posr, source_lines),
            rows: rows,
            attributes: attr.unwrap_or(vec![]),
            caption: cap_pars,
            caption_attributes: cap_attrs,
        }
    }

TableElementAttributes -> Vec<TagAttribute>
    = Space* attr:(HtmlAttribute ** (Space+)) Space* {attr}
TableParagraph -> Element
    = ParagraphTemplate<FormattedTextTemplate<Text<TableChar>>>
TableCaption -> (Vec<TagAttribute>, Vec<Element>) =
    "|+" attr:(t:TableElementAttributes "|" {t})? Space* pars:TableParagraph* {(attr.unwrap_or(vec![]), pars)}
TableCellSeparator -> &'input str
    = $("||") / $("!!") / $("|") / $("!")
TableRowSeparator -> Vec<TagAttribute>
    = "|-" attr:TableElementAttributes Newline {attr}

TableRow -> Element
    = posl:#position !("|}") sep:TableRowSeparator? c:TableCell+ posr:#position {
        
        Element::TableRow {
            position: Span::new(posl, posr, source_lines),
            cells: c,
            attributes: sep.unwrap_or(vec![]),
        }
    }

TableCell -> Element
    = posl:#position !("|}" / TableRowSeparator) sep:(TableCellSeparator) attr:(a:TableElementAttributes 
      "|" !("|") {a})? Space* content:TableParagraph+ posr:#position {

        Element::TableCell {
            position: Span::new(posl, posr, source_lines),
            content: content,
            attributes: attr.unwrap_or(vec![]),
            header: sep.starts_with("!"),
        }
    }

/*
 * References
 */

/* internal references, may have pipe-separated options */
InternalReferenceFormatted -> Element
    = FormattedTextTemplate<Text<TemplateContentChar>>

ReferenceInternal -> Element
    = posl:#position "[[" t:((tar:InternalReferenceFormatted* {tar}) ++ "|") "]]" posr:#position {
        
        let mut t = t;
        Element::InternalReference {
            position: Span::new(posl, posr, source_lines),
            target: t.remove(0),
            caption: t.pop().unwrap_or(vec![]),
            options: t, 
        }      
    }

/* external references (hyperlink) with only url and optional caption */
ReferenceExternal -> Element
    = posl:#position "[" url:Url Space* caption:FormattedText* "]" posr:#position {

        Element::ExternalReference {
            position: Span::new(posl, posr, source_lines),
            target: url,
            caption: caption
        }
    }

/*
 * Inline markup
 */

/* text markup */
StrongText -> Element
    = posl:#position Strong inner:( !("'") t:FormattedText {t} / e:EmphText {e} )+ Strong posr:#position {

        Element::Formatted {
            position: Span::new(posl, posr, source_lines),
            content: inner,
            markup: MarkupType::Bold
        }
    }

EmphText -> Element
    = posl:#position Emph inner:( !("'") t:FormattedText {t} / s:StrongText {s} )+ Emph posr:#position {
      
        Element::Formatted {
            position: Span::new(posl, posr, source_lines),
            content: inner,
            markup: MarkupType::Italic
        }
    }

/* html markup */
InlineMath -> Element
    = inner:MarkupTag<"math"i, MathText*> {inner}
StrikeThroughMarkup -> Element
    = inner:MarkupTag<"del"i, (FormattedText / Paragraph)*> {inner}
    / inner:MarkupTag<"s"i, (FormattedText / Paragraph)*> {inner}

UnderlineMarkup -> Element
    = inner:MarkupTag<"ins"i, (FormattedText / Paragraph)*> {inner}
    / inner:MarkupTag<"u"i, (FormattedText / Paragraph)*> {inner}

NoWikiMarkup -> Element
    = inner:MarkupTag<"nowiki"i, NowikiText*> {inner}
CodeMarkup -> Element
    = inner:MarkupTag<"code"i, CodeText*> {inner}
BlockquoteMarkup -> Element
    = inner:MarkupTag<"blockquote"i, (FormattedText / Paragraph)*> {inner}
PreformattedMarkup -> Element
    = inner:MarkupTag<"pre"i, PreformattedText*> {inner}


/** Template for formatted text with a specific rule for plain text. */
FormattedTextTemplate<TextRule>
    = formatted:(
    StrongText
    / EmphText 
    / Template
    / ReferenceInternal
    / ReferenceExternal
   
    / HtmlComment 
    / InlineMath
    / NoWikiMarkup
    / StrikeThroughMarkup
    / UnderlineMarkup
    / CodeMarkup
    / BlockquoteMarkup
    / PreformattedMarkup

    / AnyTag
    / TextRule
    ) {formatted}

/** Standard text element for most contexts */
FormattedText -> Element
    = f:FormattedTextTemplate<NormalText> {f}


/*
 rules for parsing embedded html 
*/

/** A html tag attribute */
HtmlAttribute -> TagAttribute
    = posl:#position key:TagName Space* "=" Space * value:(QuotedText / TagSafeLiteral) posr:#position {
        
        TagAttribute::new(Span::new(posl, posr, source_lines), key, value)
    }

TagInner<Name>
    = Space* n:Name Space* attrs:(a:HtmlAttribute Space* {a})* {(n, attrs)}
TagOpen<Name> 
    = #quiet<"<" inner:TagInner<Name> ">" {inner}> / #expected("opening html tag")
TagClose<Name> 
    = #quiet<("<" Space* "/" Space * TagInner<Name> Space* ">") / "</>"> / #expected("closing html tag")

/** a generic html tag (self-closing or with inner elements) */
HtmlTag<Name, Inner>
    = (tag:TagOpen<Name> i:Inner TagClose<Name> {(tag.0, tag.1, i)}) 
    / ("<" tag:TagInner<Name> "/" Space* ">" {(tag.0, tag.1, vec![])})

AnyOpen 
    = TagOpen<TagName?> {()}
AnyClose
    = TagClose<TagName?> {()}

/** matches any valid html tag with inner Text / Paragraph / Heading, creating a HtmlTag Element. */
AnyTag -> Element 
    = posl:#position t:HtmlTag<TagName, (FormattedText / Paragraph / Heading)*> posr:#position {
    
        Element::HtmlTag {
            position: Span::new(posl, posr, source_lines),
            name: String::from(t.0),
            attributes: t.1,
            content: t.2,
        }
}

/** macro for simple formatting markup tags. Matches markup type by tag name (see ast.rs) */
MarkupTag<Name, Inner>
    = posl:#position tag_info:HtmlTag<$(Name), Inner> posr:#position { 

        Element::Formatted {
            position: Span::new(posl, posr, source_lines),
            content: tag_info.2,
            markup: get_markup_by_tag_name(tag_info.0),
        }
    }


/** html comments may contain any text. */
HtmlComment -> Element
    = posl:#position "<!--" s:CharString<(!("-->") c:$. {c})>? "-->" posr:#position {
   
        Element::Comment {
            position: Span::new(posl, posr, source_lines),
            text: s.unwrap_or(String::new()),
        }
}

/*
 * primitive terminals
 */

Emph = "''"
Strong = "'''"

Space = " " / "\t"
Newline = "\n"

/*
 * text primitives
 */
Text<C> 
    = posl:#position s:CharString<C> posr:#position {
        
        Element::Text {
            position: Span::new(posl, posr, source_lines),
            text: s
        }
    }

CharString<C>
    = chars:C+ {
      
        let mut result = String::new();;
        for c in chars {
            result.push_str(c);
        }
        result
    }

EnclosedLiteral<ClosingChar>
    = ClosingChar text:CharString<!(ClosingChar) c:$. {c}> ClosingChar {text}


/*
 * various text types 
 */
NormalText -> Element
    = #quiet<Text<Char>> / #expected("normal text")
MathText -> Element
    = #quiet<Text<MathChar>> / #expected("LaTeX source code")
TemplateArgumentName -> String
    = #quiet<CharString<TemplateAttributeNameChar>> / #expected("template attribute name")
NowikiText -> Element
    = #quiet<Text<(!(TagClose<"nowiki"i>) $(.))>> / #expected("any text")
CodeText -> Element
    = #quiet<Text<(!(TagClose<"code"i>) $(.))>> / #expected("any text")
PreformattedText -> Element
    = #quiet<Text<(!(TagClose<"pre"i>) $(.))>> / #expected ("any text")
TemplateName -> String
    = #quiet<CharString<TemplateNameChar>> / #expected("template name")
Url -> String
    = #quiet<CharString<(!(Space / "]") c:$. {c})>> / #expected("a word of text (e.g. url)")
TagSafeLiteral -> String
    = #quiet<CharString<(!(Space / "<" / ">") c:$(.) {c})>> / #expected("tag attribute value")
QuotedText -> String 
    = #quiet<EnclosedLiteral<"\""> / EnclosedLiteral<"'">> / #expected("quoted text")
TagName -> String 
    = #quiet<CharString<!("<" / ">" / "/" / Space / "=") c:$. {c}>> / #expected("tag / attribute name")

/* 
 * character classes 
 * These characters are allowed within certain contexts, excluded characters have special meaning and break texts
 */
MathChar -> &'input str = !(TagClose<"math"i>) c:$. {c}
Char -> &'input str = !(Newline / Emph / "{" / "}" / AnyTag / AnyOpen / AnyClose / HtmlComment / "[" / "]") c:$. {c} // general inline context
HeadingChar -> &'input str = !(Newline / Emph / "{" / "}" /AnyTag / AnyOpen / AnyClose / HtmlComment / "[" / "]" / "=") c:$. {c}
TableChar -> &'input str = !(Newline / Emph / "{" / "}" / "!!" / AnyTag / AnyOpen / AnyClose / HtmlComment / "|" / "[" / "]") c:$. {c}
TemplateContentChar -> &'input str = !(Newline / Emph / "{" / "}" / AnyTag / AnyOpen / AnyClose / HtmlComment / "|" / "[" / "]") c:$. {c}
TemplateNameChar -> &'input str = !(Newline / "{{" / "}}" / "|") c:$. {c}
TemplateAttributeNameChar -> &'input str = $([A-Za-z0-9 ])

// a paragraph may not start with these symbols as they indicate other elements
PAR_START_GUARD = !("=" / "!" / "|" / "*" / "#" / ":" / ";")


use ast::*;

#![arguments(source_lines: &[SourceLine])]

/** the main document structure */
pub Document -> Element 
    = posl:#position top:Paragraph* content:Heading* end:FormattedText* posr:#position {
        let mut res = top;
        let mut content = content;
        let mut end = end;
        res.append(&mut content);
        res.append(&mut end);

        Element::Document {
            position: Span::new(posl, posr, source_lines),
            content: res, 
        }
}

/** all paragraphs after a heading belong to its content */
HeadingFormatted -> Element
    = FormattedTextTemplate<Text<HeadingChar>>
HeadingParagraph -> Element 
    = ParagraphTemplate<HeadingFormatted>

/** A heading is a caption paragraph followed by content paragraphs. */
Heading -> Element 
    = posl:#position d:$("="+) Space* caption:HeadingFormatted* "="* Space* Newline pars:Paragraph* posr:#position {
        Element::Heading {
            position: Span::new(posl, posr, source_lines),
            depth: d.len(),
            caption: caption,
            content: pars,
        }
    }

/**
 * a paragraph is a block element, some or no text followed by a newline.
 * The FormattedRule parameter is only applied to plain top-level text. All nested formatting
 * uses the standart FormattedText rule. This keeps formatted text or html tags from beeing
 * ripped apart.
 */
ParagraphTemplate<FormattedRule> 
    = List / Table / Gallery / posl:#position PAR_START_GUARD text:FormattedRule* Newline posr:#position {
       
         Element::Paragraph {
            position: Span::new(posl, posr, source_lines),
            content: text,
        }
    } 

/**
 *  the standard paragraph 
 */
Paragraph -> Element
    = ParagraphTemplate<FormattedText>


/*
 *Template parsing
 */
TemplateFormatted -> Element
    = FormattedTextTemplate<Text<TemplateContentChar>>
TemplateParagraph -> Element
    = ParagraphTemplate<TemplateFormatted>

/** 
 * mediawiki templates have a name followed by a sequence of arguments.
 * template name and arguments may also be separated with colon, but every supsequent
 * argument can only be separated by pipes.
 */
Template -> Element 
    = posl:#position "{{" Space* n:(TemplateParagraph / TemplateFormatted)* (Space / Newline)* attrs:("|" t:TemplateArgument {t})* "}}" posr:#position {
        
        Element::Template {
            position: Span::new(posl, posr, source_lines),
            name: n,
            content: attrs
        }
    }

TemplateArgument -> Element
    = posl:#position name:(n:TemplateArgumentName "=" {n})? value:(Heading / TemplateParagraph / TemplateFormatted)* posr:#position {
     
       Element::TemplateArgument {
            position: Span::new(posl, posr, source_lines),
            name: name.unwrap_or_default(),
            value: value,
        }    
    } 


/*
 mediawiki lists
 */
List -> Element
    = posl:#position items:ListItem+ Space* Newline? posr:#position {
        Element::List {
            position: Span::new(posl, posr, source_lines),
            content: items,
        }
    }

ListItem -> Element
    = posl:#position s:($("*" / "#" / ":" / ";"))+ Space* content:FormattedText* Newline? posr:#position {?
        // check if this element is at line start
        if !SourceLine::starts_line(posl, source_lines) {
            Err ("List item must start on a new line")
        } else {
        
            let kind = match s[s.len() - 1] {
                "*" => ListItemKind::Unordered,
                "#" => ListItemKind::Ordered,
                ":" => ListItemKind::Definition,
                ";" => ListItemKind::DefinitionTerm,
                _ => panic!("undefined list start: {} \
                            this should never parse until here!", s[s.len() - 1])
            };

            Ok(Element::ListItem {
                position: Span::new(posl, posr, source_lines),
                depth: s.len(),
                kind: kind,
                content: content,
            })
        }
    }

/*
 mediawiki tables
 */
Table -> Element
    = posl:#position "{|" attr:TableElementAttributes? (Space / Newline)* caption:TableCaption? first_cells:TableCell* rows:TableRow* "|}" posr:#position { 
    
        let (cap_attrs, cap_pars) = caption.unwrap_or_default();
        let mut rows = rows;
        if first_cells.len() > 0 {
            rows.insert(0, Element::TableRow {
                position: Span::new(0, 0, source_lines),
                cells: first_cells,
                attributes: vec![],
            });
        }
        Element::Table {
            position: Span::new(posl, posr, source_lines),
            rows: rows,
            attributes: attr.unwrap_or_default(),
            caption: cap_pars,
            caption_attributes: cap_attrs,
        }
    }

TableElementAttributes -> Vec<TagAttribute>
    = Space* attr:(HtmlAttribute ** (Space+)) Space* {attr}
TableFormatted -> Element
    = !("!") FormattedTextTemplate<Text<TableChar>>
TableParagraph -> Element
    = ParagraphTemplate<TableFormatted>
TableCaption -> (Vec<TagAttribute>, Vec<Element>) =
    "|+" attr:(t:TableElementAttributes "|" {t})? Space* pars:(TableParagraph / TableFormatted)* {(attr.unwrap_or_default(), pars)}
TableCellSeparator -> &'input str
    = $("||") / $("!!") / $("|") / $("!")
TableRowSeparator -> Vec<TagAttribute>
    = "|-" attr:TableElementAttributes Newline {attr}

TableRow -> Element
    = posl:#position !("|}") sep:TableRowSeparator c:TableCell* posr:#position {
        
        Element::TableRow {
            position: Span::new(posl, posr, source_lines),
            cells: c,
            attributes: sep,
        }
    }

TableCell -> Element
    = posl:#position !("|}" / TableRowSeparator) sep:(TableCellSeparator) attr:(a:TableElementAttributes 
      "|" !("|") {a})? Space* content:(TableParagraph / TableFormatted)* posr:#position {

        Element::TableCell {
            position: Span::new(posl, posr, source_lines),
            content: content,
            attributes: attr.unwrap_or_default(),
            header: sep.starts_with('!'),
        }
    }

/*
 * References
 */

/* internal references, may have pipe-separated options */
InternalReferenceFormatted -> Element
    = FormattedTextTemplate<Text<TemplateContentChar>>
InternalRefParagraph -> Element
    = ParagraphTemplate<InternalReferenceFormatted>

ReferenceInternal -> Element
    = posl:#position "[[" t:((tar:(InternalRefParagraph / InternalReferenceFormatted)* {tar}) ++ "|") "]]" posr:#position {
        
        let mut t = t;
        Element::InternalReference {
            position: Span::new(posl, posr, source_lines),
            target: t.remove(0),
            caption: t.pop().unwrap_or_default(),
            options: t, 
        }      
    }

/* external references (hyperlink) with only url and optional caption */
ReferenceExternal -> Element
    = posl:#position "[" url:Url Space* caption:(Paragraph / FormattedText)* "]" posr:#position {

        Element::ExternalReference {
            position: Span::new(posl, posr, source_lines),
            target: url,
            caption: caption
        }
    }

/*
 * Galleries
 */
GallerySep = (Space* Newline Space*)+

Gallery -> Element 
    = posl:#position attr:TagOpen<"gallery"i> GallerySep* files:(
        (flp:#position content:(f:InternalReferenceFormatted+ {f}) ++ "|" frp:#position {
            let mut content = content;
            Element::InternalReference {
                position: Span::new(flp, frp, source_lines),
                target: content.remove(0),
                caption: content.pop().unwrap_or_default(),
                options: content,
            }
        })
    ** GallerySep) GallerySep* TagClose<"gallery"i> posr:#position {
    Element::Gallery {
        position: Span::new(posl, posr, source_lines),
        attributes: attr.1,
        content: files,
    }
}

/*
 * Inline markup
 */

/* text markup */

/* formatted text cannot start with a single quote, except they are "Included" */
QuoteFormattedTemplate<Included> = text:((!("'") t:FormattedText {t}) / Included) {text}
StrongFormatted -> Element
    = QuoteFormattedTemplate<EmphText>
EmphFormatted -> Element
    = QuoteFormattedTemplate<StrongText>

StrongText -> Element
    = posl:#position Strong inner:(ParagraphTemplate<StrongFormatted> / StrongFormatted)+ Strong posr:#position {

        Element::Formatted {
            position: Span::new(posl, posr, source_lines),
            content: inner,
            markup: MarkupType::Bold
        }
    }

EmphText -> Element
    = posl:#position Emph inner:(ParagraphTemplate<EmphFormatted> / EmphFormatted)+ Emph posr:#position {
      
        Element::Formatted {
            position: Span::new(posl, posr, source_lines),
            content: inner,
            markup: MarkupType::Italic
        }
    }

/* html markup */
InlineMath -> Element
    = inner:MarkupTag<"math"i, MathText*> {inner}
StrikeThroughMarkup -> Element
    = inner:MarkupTag<"del"i, (Paragraph / FormattedText)*> {inner}
    / inner:MarkupTag<"s"i, (Paragraph / FormattedText)*> {inner}

UnderlineMarkup -> Element
    = inner:MarkupTag<"ins"i, (Paragraph / FormattedText)*> {inner}
    / inner:MarkupTag<"u"i, (Paragraph / FormattedText)*> {inner}

NoWikiMarkup -> Element
    = inner:MarkupTag<"nowiki"i, NowikiText*> {inner}
CodeMarkup -> Element
    = inner:MarkupTag<"code"i, CodeText*> {inner}
BlockquoteMarkup -> Element
    = inner:MarkupTag<"blockquote"i, (Paragraph / FormattedText)*> {inner}
PreformattedMarkup -> Element
    = inner:MarkupTag<"pre"i, PreformattedText*> {inner}


/** Template for formatted text with a specific rule for plain text. */
FormattedTextTemplate<TextRule>
    = formatted:(
    StrongText
    / EmphText 
    / Template
    / ReferenceInternal
    / ReferenceExternal

    / HtmlComment 
    / InlineMath
    / NoWikiMarkup
    / StrikeThroughMarkup
    / UnderlineMarkup
    / CodeMarkup
    / BlockquoteMarkup
    / PreformattedMarkup

    / AnyTag
    / TextRule
    ) {formatted}

/** Standard text element for most contexts */
FormattedText -> Element
    = f:FormattedTextTemplate<NormalText> {f}


/*
 rules for parsing embedded html 
*/

/** A html tag attribute */
HtmlAttribute -> TagAttribute
    = posl:#position key:TagName Space* "=" Space * value:(QuotedText / TagSafeLiteral) posr:#position {
        
        TagAttribute::new(Span::new(posl, posr, source_lines), key, value)
    }

TagInner<Name>
    = Space* n:Name Space* attrs:(a:HtmlAttribute Space* {a})* {(n, attrs)}
TagOpen<Name> 
    = #quiet<"<" inner:TagInner<Name> ">" {inner}> / #expected("opening html tag")
TagClose<Name> 
    = #quiet<("<" Space* "/" Space * TagInner<Name> Space* ">") / "</>"> / #expected("closing html tag")

/** a generic html tag (self-closing or with inner elements) */
HtmlTag<Name, Inner>
    = (tag:TagOpen<Name> i:Inner TagClose<Name> {(tag.0, tag.1, i)}) 
    / ("<" tag:TagInner<Name> "/" Space* ">" {(tag.0, tag.1, vec![])})

AnyOpen 
    = TagOpen<TagName?> {()}
AnyClose
    = TagClose<TagName?> {()}

/** matches any valid html tag (except builtins like "gallery" with inner Text / Paragraph / Heading, creating a HtmlTag Element. */
AnyTag -> Element 
    = posl:#position t:HtmlTag<(!HTML_BLOCK_ELEMENTS n:TagName {n}), (Paragraph / FormattedText / Heading)*> posr:#position {
    
        Element::HtmlTag {
            position: Span::new(posl, posr, source_lines),
            name: t.0,
            attributes: t.1,
            content: t.2,
        }
}

/** macro for simple formatting markup tags. Matches markup type by tag name (see ast.rs) */
MarkupTag<Name, Inner>
    = posl:#position tag_info:HtmlTag<$(Name), Inner> posr:#position { 

        Element::Formatted {
            position: Span::new(posl, posr, source_lines),
            content: tag_info.2,
            markup: MarkupType::by_tag_name(tag_info.0),
        }
    }


/** html comments may contain any text. */
HtmlComment -> Element
    = posl:#position "<!--" s:CharString<(!("-->") c:$. {c})>? "-->" posr:#position {
   
        Element::Comment {
            position: Span::new(posl, posr, source_lines),
            text: s.unwrap_or_default(),
        }
}

/*
 * primitive terminals
 */

Emph = "''"
Strong = "'''"

Space = " " / "\t"
Newline = "\n"

/*
 * text primitives
 */
Text<C> 
    = posl:#position s:CharString<C> posr:#position {
        
        Element::Text {
            position: Span::new(posl, posr, source_lines),
            text: s
        }
    }

CharString<C>
    = chars:C+ {
      
        let mut result = String::new();;
        for c in chars {
            result.push_str(c);
        }
        result
    }

EnclosedLiteral<ClosingChar>
    = ClosingChar text:CharString<!(ClosingChar) c:$. {c}> ClosingChar {text}


/*
 * various text types 
 */
NormalText -> Element
    = #quiet<Text<Char>> / #expected("normal text")
MathText -> Element
    = #quiet<Text<MathChar>> / #expected("LaTeX source code")
TemplateArgumentName -> String
    = #quiet<CharString<TemplateAttributeNameChar>> / #expected("template attribute name")
NowikiText -> Element
    = #quiet<Text<(!(TagClose<"nowiki"i>) $(.))>> / #expected("any text")
CodeText -> Element
    = #quiet<Text<(!(TagClose<"code"i>) $(.))>> / #expected("any text")
PreformattedText -> Element
    = #quiet<Text<(!(TagClose<"pre"i>) $(.))>> / #expected ("any text")
Url -> String
    = #quiet<CharString<(!(Space / "]") c:$. {c})>> / #expected("a word of text (e.g. url)")
TagSafeLiteral -> String
    = #quiet<CharString<(!(Space / "<" / "/" / ">") c:$(.) {c})>> / #expected("tag attribute value")
QuotedText -> String 
    = #quiet<EnclosedLiteral<"\""> / EnclosedLiteral<"'">> / #expected("quoted text")
TagName -> String 
    = #quiet<CharString<!("<" / ">" / "/" / Space / "=") c:$. {c}>> / #expected("tag / attribute name")

/* 
 * character classes 
 * These characters are allowed within certain contexts, excluded characters have special meaning and break texts
 */
MathChar -> &'input str = !(TagClose<"math"i>) c:$. {c}
Char -> &'input str = !(Newline / Emph / Strong / "{" / "}" / AnyTag / AnyOpen / AnyClose / HtmlComment / "[" / "]") c:$. {c} // general inline context
HeadingChar -> &'input str = !(Newline / Emph / "{" / "}" /AnyTag / AnyOpen / AnyClose / HtmlComment / "[" / "]" / "=") c:$. {c}
TableChar -> &'input str = !(Newline / Emph / "{" / "}" / "!!" / AnyTag / AnyOpen / AnyClose / HtmlComment / "|" / "[" / "]") c:$. {c}
TemplateContentChar -> &'input str = !(Newline / Emph / "{" / "}" / AnyTag / AnyOpen / AnyClose / HtmlComment / "|" / "[" / "]") c:$. {c}
TemplateAttributeNameChar -> &'input str = !(Newline / "{" / "}" / "|" / "<" / ">" / "[" / "]" / "=" / "!" / "*" / "#" / ":" / ";" / "/") c:$. {c}

// a paragraph may not start with these symbols as they indicate other elements
PAR_START_GUARD = !("=" / "!" / "|" / "*" / "#" / ":" / ";")
// tags which should be parsed as block elements, rather than html tags.
HTML_BLOCK_ELEMENTS = ("gallery"i)

use ast::*;

#![arguments(source_lines: &Vec<SourceLine>)]


/* the main document structure */
pub Document -> Element = posl:#position top:Paragraph* content:Heading* {
    let mut res = top;
    let mut content = content;
    res.append(&mut content);
    
    Element::Document {
        position: Position::new(posl, source_lines),
        content: res, 
    }
}

/* all paragraphs after a heading belong to its content */
Heading -> Element = posl:#position d:$("="+) Space* caption:Paragraph pars:Paragraph* {
        Element::Heading {
            position: Position::new(posl, source_lines),
            depth: d.len(),
            caption: Box::new(caption),
            content: pars,
        }
    }

/* a paragraph is a block element, some or no text followed by a newline or just some text */
Paragraph -> Element = 
    List
    / Table
    / posl:#position PAR_START_GUARD text:((t:FormattedText* Newline {t}) / (f:FormattedText+ Newline? {f})) {
        Element::Paragraph {
            position: Position::new(posl, source_lines),
            content: text,
        }
    } 

/* mediawiki templates */
Template -> Element = 
    posl:#position "{{" Space* n:TemplateName (Space / Newline)* attrs:("|" t:TemplateArgument {t})* "}}" {
    Element::Template {
        position: Position::new(posl, source_lines),
        name: Box::new(n),
        content: attrs
    }
}

TemplateArgument -> Element = 
    posl:#position name:(n:TemplateArgumentName "=" {n})? value:(Paragraph / FormattedText)+ {
        Element::TemplateArgument {
            position: Position::new(posl, source_lines),
            name: Box::new(name),
            value: value,
        }    
    } 


/* mediawiki lists */
List -> Element = 
    posl:#position items:ListItem+ Space* Newline?  {
        Element::List {
            position: Position::new(posl, source_lines),
            content: items,
        }
    }

ListItem -> Element = 
    Space* posl:#position s:($("*" / "#" / ":" / ";"))+ Space* content:FormattedText* Newline? {
        let kind = match s[s.len() - 1] {
            "*" => ListItemKind::Unordered,
            "#" => ListItemKind::Ordered,
            ":" => ListItemKind::Definition,
            ";" => ListItemKind::DefinitionTerm,
            _ => ListItemKind::Unordered,
        };

        Element::ListItem {
            position: Position::new(posl, source_lines),
            depth: s.len(),
            kind: kind,
            content: content,
        }
    }

/* mediawiki tables */
Table -> Element = 
    posl:#position "{|" attr:TableAttributeText? Newline (Space / Newline)* caption:TableCaption? rows:TableRow* "|}" { 
        let (cap_attrs, cap_pars) = caption.unwrap_or((String::new(), vec![]));

        Element::Table {
            position: Position::new(posl, source_lines),
            rows: rows,
            attributes: attr.unwrap_or(String::new()),
            caption: cap_pars,
            caption_attributes: cap_attrs,
        }
    }

TableCaption -> (String, Vec<Element>) = "|+" attr:(t:TableAttributeText "|" {t})? Space* pars:Paragraph* {(String::from(attr.unwrap_or(String::new()).trim()), pars)}
TableAttributeText -> String = attr:CharString<(!("|" / "!" / Newline) c:$. {c})> { String::from(attr.trim()) }
TableCellSeparator -> &'input str = $("||") / $("!!") / $("|") / $("!")
TableRowSeparator -> String = "|-"  attr:TableAttributeText? Newline { attr.unwrap_or(String::new()) }

TableRow -> Element =
    posl:#position !("|}") sep:TableRowSeparator? c:TableCell* {
        Element::TableRow {
            position: Position::new(posl, source_lines),
            cells: c,
            attributes: sep.unwrap_or(String::new()),
        }
    }

TableCell -> Element = 
    posl:#position !("|}" / TableRowSeparator) sep:(TableCellSeparator) attr:(a:TableAttributeText "|" !("|") {a})? Space* content:Paragraph+ {
        Element::TableCell {
            position: Position::new(posl, source_lines),
            content: content,
            attributes: attr.unwrap_or(String::new()),
            header: sep.starts_with("!"),
        }
    }

/* internal references, may have pipe-separated options */
ReferenceInternal -> Element =
    posl:#position "[[" t:((tar:FormattedText* {tar}) ++ "|") "]]" {
        let mut t = t;
        Element::InternalReference {
            position: Position::new(posl, source_lines),
            target: t.remove(0),
            caption: t.pop().unwrap_or(vec![]),
            options: t, 
        }      
    }

/* external references (hyperlink) with only url and optional caption */
ReferenceExternal -> Element = 
    posl:#position
    "[" url:Word Space? caption:FormattedText* "]" {
        Element::ExternalReference {
            position: Position::new(posl, source_lines),
            target: url,
            caption: caption
        }
    }

/* text markup */
StrongText -> Element =  
    posl:#position 
    Strong
    inner:( !("'") t:FormattedText {t} / e:EmphText {e} )+
    Strong {
        Element::Formatted {
            position: Position::new(posl, source_lines),
            content: inner,
            markup: MarkupType::Bold
        }
    }

EmphText -> Element =  
    posl:#position 
    Emph
    inner:( !("'") t:FormattedText {t} / s:StrongText {s} )+
    Emph {
        Element::Formatted {
            position: Position::new(posl, source_lines),
            content: inner,
            markup: MarkupType::Italic
        }
    }

InlineMath -> Element = 
    posl:#position
    BeginMath
    inner:MathText*
    EndMath {
        Element::Formatted {
            position: Position::new(posl, source_lines),
            content: inner,
            markup: MarkupType::Math
        }
    }

StrikeThroughMarkup -> Element = 
    posl:#position
    BeginStrikethrough
    inner:FormattedText+
    EndStrikethrough {
        Element::Formatted {
            position: Position::new(posl, source_lines),
            content: inner,
            markup: MarkupType::StrikeThrough
        }
    }

NoWikiMarkup -> Element = 
    posl:#position
    BeginNoWiki
    inner: NowikiText*
    EndNoWiki {
        Element::Formatted {
            position: Position::new(posl, source_lines),
            content: inner,
            markup: MarkupType::NoWiki
        }
    }

SingleQuoteText -> Element = posl:#position q:$("'") {
    Element::Text {
        position: Position::new(posl, source_lines),
        text: String::from(q),
    }
}


pub FormattedText -> Element = StrongText
    / EmphText 
    / t:Template {t}
    / InlineMath
    / ReferenceInternal
    / ReferenceExternal
    / NoWikiMarkup
    / StrikeThroughMarkup
    / (posl:#position t:NormalText {t})
    / SingleQuoteText


/* primitive terminals */

Emph = "''"
Strong = "'''"

Space = " " / "\t"
Newline = "\n"
BeginMath = "<math>" / "<MATH>"
EndMath = "</math>" / "</MATH>"
BeginNoWiki = "<nowiki>" / "<NOWIKI>"
EndNoWiki = "</nowiki>" / "</NOWIKI>"
BeginStrikethrough = "<del>" / "<s>" / "<DEL>"
EndStrikethrough = "</del>" / "</s>" / "</DEL>"
// a paragraph may not start with these symbols as they indicate other elements
PAR_START_GUARD = !("=" / "!" / "|" / "*" / "#" / ":" / ";")

Text<C> = 
    posl:#position s:CharString<C> {
        Element::Text {
            position: Position::new(posl, source_lines),
            text: s
        }
    }

CharString<C> = 
    chars:C+ {
        let mut result = String::new();;
        for c in chars {
            result.push_str(c);
        }
        result
    }

/* primitive strings */
NormalText -> Element = #quiet<Text<Char>> / #expected("normal text")
MathText -> Element = #quiet<Text<MathChar>> / #expected("LaTeX source code")
TemplateArgumentName -> Element = #quiet<Text<TemplateChar>> / #expected("template attribute name")
NowikiText -> Element = #quiet<Text<(!(EndNoWiki) $(.))>> / #expected("any text")
TemplateName -> Element = #quiet<Text<TemplateNameChar>> / #expected("template name")
Word -> String =  #quiet<CharString<(!(Space) c:Char {c})>> / #expected("url")

/* character classes */
MathChar -> &'input str = !(Newline / BeginMath / EndMath) c:$. {c}
Char -> &'input str = !(Newline / "'" / "{" / "}" / "!!"  / "|" / "[" / "]" / BeginMath / EndMath / BeginNoWiki / EndNoWiki / BeginStrikethrough / EndStrikethrough) c:$. {c}
TemplateNameChar -> &'input str = !(Newline / "{{" / "}}" / "|") c:$. {c}
TemplateChar -> &'input str = $([A-Za-z0-9 ])

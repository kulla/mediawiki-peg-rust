use ast::*;

#![arguments(source_lines: &Vec<SourceLine>)]


pub Document -> Element = posl:#position top:Paragraph* content:Heading* {
    let mut top = top;
    let mut content = content;
    let mut c = Vec::new(); 
    c.append(&mut top);
    c.append(&mut content);
    
    Element::Document {
        position: Position::new(posl, source_lines),
        content: c, 
    }
}

pub Heading -> Element = posl:#position d:$(Equal+) Space* caption:Paragraph pars:Paragraph*
    {
        Element::Heading {
            position: Position::new(posl, source_lines),
            depth: d.len(),
            caption: Box::new(caption),
            content: pars,
        }
    }


pub Paragraph -> Element = 
    posl:#position text:FormattedText* Newline {
        Element::Paragraph {
            position: Position::new(posl, source_lines),
            content: text,
        }
    }
    /
    /* end of file paragraph */
    posl:#position text:FormattedText+ !(".") {
        Element::Paragraph {
            position: Position::new(posl, source_lines),
            content: text,
        }
    }

pub TemplateAttribute -> Element = 
    posl:#position name:TemplateText Equal value:(FormattedText / Paragraph)+ {
        Element::TemplateAttribute {
            position: Position::new(posl, source_lines),
            name: Box::new(Some(name)),
            value: value,
        }    
    } 
    /
    posl:#position value:(FormattedText / Paragraph)+ {
        Element::TemplateAttribute {
            position: Position::new(posl, source_lines),
            name: Box::new(None),
            value: value,
        }
    }

pub Template -> Element = 
    posl:#position TemplateOpen s:TemplateAttribute attrs:(Pipe t:TemplateAttribute {t})* TemplateClose {
    let mut attrs = attrs;
    attrs.insert(0, s);
    Element::Template {
        position: Position::new(posl, source_lines),
        content: attrs
    }
}

StrongText -> Element =  
    posl:#position 
    Strong
    inner:( !(Quote) t:FormattedText {t} / e:EmphText {e} )+
    Strong {
        Element::Formatted {
            position: Position::new(posl, source_lines),
            content: inner,
            markup: MarkupType::Bold
        }
    }

EmphText -> Element =  
    posl:#position 
    Emph
    inner:( !(Quote) t:FormattedText {t} / s:StrongText {s} )+
    Emph {
        Element::Formatted {
            position: Position::new(posl, source_lines),
            content: inner,
            markup: MarkupType::Italic
        }
    }


pub FormattedText -> Element = StrongText
    / EmphText 
    / (posl:#position t:NormalText {t})


/* primitive terminals */

Emph = "''"
Strong = "'''"

Newline = "\n"
Equal = "="
TemplateOpen = "{{"
TemplateClose = "}}"
Space = " "
Quote = "\'"
Dollar = "$"
Pipe = "|"
Fence = "#"

Text<C> = posl:#position chars:C+ {
    let mut content = String::new();
    for c in chars {
        content.push_str(c);
    }
    Element::Text {
        position: Position::new(posl, source_lines),
        text: content
    }
}

NormalText -> Element = #quiet<Text<Char>> / #expected("normal text")
MathText -> Element = #quiet<Text<MathChar>> / #expected("LaTeX source code")
TemplateText -> Element = #quiet<Text<TemplateChar>> / #expected("template text")


MathChar -> &'input str = !(Newline / Dollar) c:$. {c}
Char -> &'input str = !(Equal / Newline / Quote /  TemplateOpen / TemplateClose / Dollar / Pipe) c:$. {c}
TemplateChar -> &'input str = !(Newline / TemplateOpen / TemplateClose / Pipe / Fence / Equal) c:$. {c}



use ast::*;

#![arguments(source_lines: &Vec<SourceLine>)]

/* the main document structure */
pub Document -> Element = posl:#position top:Paragraph* content:Heading* posr:#position {
    let mut res = top;
    let mut content = content;
    res.append(&mut content);
    
    Element::Document {
        position: Span::new(posl, posr, source_lines),
        content: res, 
    }
}

/* all paragraphs after a heading belong to its content */
HeadingParagraph -> Element = ParagraphTemplate<FormattedTextTemplate<Text<HeadingChar>, UnmatchedText>>
Heading -> Element = posl:#position d:$("="+) Space* caption:HeadingParagraph "="* pars:Paragraph* posr:#position {
        Element::Heading {
            position: Span::new(posl, posr, source_lines),
            depth: d.len(),
            caption: Box::new(caption),
            content: pars,
        }
    }

/* a paragraph is a block element, some or no text followed by a newline or just some text */
ParagraphTemplate<FormattedRule> = 
    List
    / Table
    / posl:#position PAR_START_GUARD text:((t:FormattedRule* Newline {t}) 
        / (f:FormattedRule+ Newline? {f})) posr:#position {
       
         Element::Paragraph {
            position: Span::new(posl, posr, source_lines),
            content: text,
        }
    } 

Paragraph -> Element = ParagraphTemplate<FormattedText>


/* mediawiki templates */
TemplateParagraph -> Element = ParagraphTemplate<FormattedTextTemplate<Text<TemplateContentChar>, UnmatchedText>>
Template -> Element = 
    posl:#position "{{" Space* n:TemplateName (Space / Newline)* attrs:("|" t:TemplateArgument {t})* "}}" posr:#position {
    Element::Template {
        position: Span::new(posl, posr, source_lines),
        name: n,
        content: attrs
    }
}

TemplateArgument -> Element = 
    posl:#position name:(n:TemplateArgumentName "=" {n})? value:TemplateParagraph+ posr:#position {
        Element::TemplateArgument {
            position: Span::new(posl, posr, source_lines),
            name: name.unwrap_or(String::new()),
            value: value,
        }    
    } 


/* mediawiki lists */
List -> Element = 
    posl:#position items:ListItem+ Space* Newline? posr:#position {
        Element::List {
            position: Span::new(posl, posr, source_lines),
            content: items,
        }
    }

ListItem -> Element = 
    Space* posl:#position s:($("*" / "#" / ":" / ";"))+ Space* content:FormattedText* Newline? posr:#position {
        let kind = match s[s.len() - 1] {
            "*" => ListItemKind::Unordered,
            "#" => ListItemKind::Ordered,
            ":" => ListItemKind::Definition,
            ";" => ListItemKind::DefinitionTerm,
            _ => ListItemKind::Unordered,
        };

        Element::ListItem {
            position: Span::new(posl, posr, source_lines),
            depth: s.len(),
            kind: kind,
            content: content,
        }
    }

/* mediawiki tables */
Table -> Element = 
    posl:#position "{|" attr:TableAttributeText? Newline (Space / Newline)* caption:TableCaption? rows:TableRow* "|}" posr:#position { 
        let (cap_attrs, cap_pars) = caption.unwrap_or((String::new(), vec![]));

        Element::Table {
            position: Span::new(posl, posr, source_lines),
            rows: rows,
            attributes: attr.unwrap_or(String::new()),
            caption: cap_pars,
            caption_attributes: cap_attrs,
        }
    }

TableParagraph -> Element = ParagraphTemplate<FormattedTextTemplate<Text<TableChar>, UnmatchedText>>
TableCaption -> (String, Vec<Element>) = "|+" attr:(t:TableAttributeText "|" {t})? Space* pars:TableParagraph* {(String::from(attr.unwrap_or(String::new()).trim()), pars)}
TableAttributeText -> String = attr:CharString<(!("|" / "!" / Newline) c:$. {c})> { String::from(attr.trim()) }
TableCellSeparator -> &'input str = $("||") / $("!!") / $("|") / $("!")
TableRowSeparator -> String = "|-"  attr:TableAttributeText? Newline { attr.unwrap_or(String::new()) }

TableRow -> Element =
    posl:#position !("|}") sep:TableRowSeparator? c:TableCell* posr:#position {
        Element::TableRow {
            position: Span::new(posl, posr, source_lines),
            cells: c,
            attributes: sep.unwrap_or(String::new()),
        }
    }

TableCell -> Element = 
    posl:#position !("|}" / TableRowSeparator) sep:(TableCellSeparator) attr:(a:TableAttributeText 
    "|" !("|") {a})? Space* content:TableParagraph+ posr:#position {

        Element::TableCell {
            position: Span::new(posl, posr, source_lines),
            content: content,
            attributes: attr.unwrap_or(String::new()),
            header: sep.starts_with("!"),
        }
    }

/* internal references, may have pipe-separated options */
InternalReferenceFormatted -> Element = FormattedTextTemplate<Text<TemplateContentChar>, UnmatchedText>
ReferenceInternal -> Element =
    posl:#position "[[" t:((tar:InternalReferenceFormatted* {tar}) ++ "|") "]]" posr:#position {
        let mut t = t;
        Element::InternalReference {
            position: Span::new(posl, posr, source_lines),
            target: t.remove(0),
            caption: t.pop().unwrap_or(vec![]),
            options: t, 
        }      
    }

/* external references (hyperlink) with only url and optional caption */
ReferenceExternal -> Element = 
    posl:#position "[" url:Word Space* caption:FormattedText* "]" posr:#position {
        Element::ExternalReference {
            position: Span::new(posl, posr, source_lines),
            target: url,
            caption: caption
        }
    }

/* text markup */
StrongText -> Element =  
    posl:#position Strong inner:( !("'") t:FormattedText {t} / e:EmphText {e} )+ Strong posr:#position {
        Element::Formatted {
            position: Span::new(posl, posr, source_lines),
            content: inner,
            markup: MarkupType::Bold
        }
    }

EmphText -> Element =  
    posl:#position Emph inner:( !("'") t:FormattedText {t} / s:StrongText {s} )+ Emph posr:#position {
        Element::Formatted {
            position: Span::new(posl, posr, source_lines),
            content: inner,
            markup: MarkupType::Italic
        }
    }

InlineMath -> Element = inner:MarkupTag<"math"i, MathText*> {inner}
StrikeThroughMarkup -> Element = inner:MarkupTag<"del"i, Paragraph*> {inner}
    / inner:MarkupTag<"s"i, Paragraph*> {inner}

UnderlineMarkup -> Element = inner:MarkupTag<"ins"i, Paragraph*> {inner}
    / inner:MarkupTag<"u"i, Paragraph*> {inner}

NoWikiMarkup -> Element = inner:MarkupTag<"nowiki"i, NowikiText*> {inner}
DefinitionMarkup -> Element = inner:MarkupTag<"dfn"i, Paragraph*> {inner}
CodeMarkup -> Element = inner:MarkupTag<"code"i, Paragraph*> {inner}
BlockquoteMarkup -> Element = inner:MarkupTag<"blockquote"i, Paragraph*> {inner}
PreformattedMarkup -> Element = inner:MarkupTag<"pre"i, PreformattedText*> {inner}
TranslationMarkup -> Element = inner:MarkupTag<"translate"i, (Paragraph / Heading)*> {inner}

/* any unmatched characters which normally indicate special function */
UnmatchedText -> Element = posl:#position q:($("'") / $(">") / !(TagOpen<Word>) $("<")) posr:#position {
    Element::Text {
        position: Span::new(posl, posr, source_lines),
        text: String::from(q),
    }
}

FormattedTextTemplate<TextRule, UnmatchedRule> = formatted:(
    StrongText
    / EmphText 
    / Template
    / ReferenceInternal
    / ReferenceExternal
   
    / HtmlComment 
    / InlineMath
    / NoWikiMarkup
    / StrikeThroughMarkup
    / DefinitionMarkup
    / UnderlineMarkup
    / CodeMarkup
    / BlockquoteMarkup
    / PreformattedMarkup
    / TranslationMarkup

    / TextRule
    / UnmatchedRule
    ) {formatted}

FormattedText -> Element = f:FormattedTextTemplate<NormalText, UnmatchedText> {f}

/* html tags */
TagOpen<Name> = "<" Space* n:$(Name) Char* ">" {n}
TagClose<Name> = "<" Space* "/" Space * Name Space* ">"
HtmlTag<Name, Inner> = n:TagOpen<Name> i:Inner TagClose<Name> {(n, i)}
HtmlComment -> Element = posl:#position "<!--" s:CharString<(!("-->") c:$. {c})> "-->" posr:#position {
    Element::Comment {
        position: Span::new(posl, posr, source_lines),
        text: s
    }
}

/* macro for simple formatting markup tags. Matches markup type by tag name (see ast.rs) */
MarkupTag<Name, Inner> = posl:#position tag_info:HtmlTag<Name, Inner> posr:#position { 
        Element::Formatted {
            position: Span::new(posl, posr, source_lines),
            content: tag_info.1,
            markup: get_markup_by_tag_name(tag_info.0),
        }
    }


/* primitive terminals */

Emph = "''"
Strong = "'''"

Space = " " / "\t"
Newline = "\n"
// a paragraph may not start with these symbols as they indicate other elements
PAR_START_GUARD = !("=" / "!" / "|" / "*" / "#" / ":" / ";")

Text<C> = 
    posl:#position s:CharString<C> posr:#position {
        Element::Text {
            position: Span::new(posl, posr, source_lines),
            text: s
        }
    }

CharString<C> = 
    chars:C+ {
        let mut result = String::new();;
        for c in chars {
            result.push_str(c);
        }
        result
    }

/* primitive strings */
NormalText -> Element = #quiet<Text<Char>> / #expected("normal text")
MathText -> Element = #quiet<Text<MathChar>> / #expected("LaTeX source code")
TemplateArgumentName -> String = #quiet<CharString<TemplateAttributeNameChar>> / #expected("template attribute name")
NowikiText -> Element = #quiet<Text<(!(TagClose<"nowiki"i>) $(.))>> / #expected("any text")
PreformattedText -> Element = #quiet<Text<(!(TagClose<"pre"i>) $(.))>> / #expected ("any text")
TemplateName -> String = #quiet<CharString<TemplateNameChar>> / #expected("template name")
Word -> String =  #quiet<CharString<(!(Space) c:Char {c})>> / #expected("url")

/* character classes */
// These characters are allowed within certain contexts, other characters have special meaning and break texts
MathChar -> &'input str = !(TagClose<"math"i>) c:$. {c}
Char -> &'input str = !(Newline / "'" / "{" / "}" / "<" / ">" / "[" / "]") c:$. {c} // general inline context
HeadingChar -> &'input str = !(Newline / "'" / "{" / "}" / "<" / ">" / "[" / "]" / "=") c:$. {c}
TableChar -> &'input str = !(Newline / "'" / "{" / "}" / "!!" / "<" / ">" / "|" / "[" / "]") c:$. {c}
TemplateContentChar -> &'input str = !(Newline / "'" / "{" / "}" / "<" / ">" / "|" / "[" / "]") c:$. {c}
TemplateNameChar -> &'input str = !(Newline / "{{" / "}}" / "|") c:$. {c}
TemplateAttributeNameChar -> &'input str = $([A-Za-z0-9 ])

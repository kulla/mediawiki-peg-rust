use ast::*;

#![arguments(source_lines: &Vec<SourceLine>)]


pub Document -> Element = posl:#position top:Paragraph* content:Heading* {
    let mut top = top;
    let mut content = content;
    let mut c = Vec::new(); 
    c.append(&mut top);
    c.append(&mut content);
    
    Element::Document {
        position: Position::new(posl, source_lines),
        content: c, 
    }
}

pub Heading -> Element = posl:#position d:$(Equal+) Space* caption:Paragraph pars:Paragraph*
    {
        Element::Heading {
            position: Position::new(posl, source_lines),
            depth: d.len(),
            caption: Box::new(caption),
            content: pars,
        }
    }


pub Paragraph -> Element = 
    posl:#position text:FormattedText* Newline {
        Element::Paragraph {
            position: Position::new(posl, source_lines),
            content: text,
        }
    }
    /
    /* end of file paragraph */
    posl:#position text:FormattedText+ !(".") {
        Element::Paragraph {
            position: Position::new(posl, source_lines),
            content: text,
        }
    }

pub TemplateAttribute -> Element = 
    posl:#position name:TemplateAttributeName Equal value:(FormattedText / Paragraph)+ {
        Element::TemplateAttribute {
            position: Position::new(posl, source_lines),
            name: Box::new(Some(name)),
            value: value,
        }    
    } 
    /
    posl:#position value:(FormattedText / Paragraph)+ {
        Element::TemplateAttribute {
            position: Position::new(posl, source_lines),
            name: Box::new(None),
            value: value,
        }
    }

pub Template -> Element = 
    posl:#position TemplateOpen s:TemplateAttribute attrs:(Pipe t:TemplateAttribute {t})* TemplateClose {
    let mut attrs = attrs;
    attrs.insert(0, s);
    Element::Template {
        position: Position::new(posl, source_lines),
        content: attrs
    }
}

Reference -> Element = 
    posl:#position
    "[" url:Word Space? caption:FormattedText* "]" {
        Element::Reference {
            position: Position::new(posl, source_lines),
            target: url,
            caption: caption
        }
    }

StrongText -> Element =  
    posl:#position 
    Strong
    inner:( !(Quote) t:FormattedText {t} / e:EmphText {e} )+
    Strong {
        Element::Formatted {
            position: Position::new(posl, source_lines),
            content: inner,
            markup: MarkupType::Bold
        }
    }

EmphText -> Element =  
    posl:#position 
    Emph
    inner:( !(Quote) t:FormattedText {t} / s:StrongText {s} )+
    Emph {
        Element::Formatted {
            position: Position::new(posl, source_lines),
            content: inner,
            markup: MarkupType::Italic
        }
    }

InlineMath -> Element = 
    posl:#position
    BeginMath
    inner:MathText+
    EndMath {
        Element::Formatted {
            position: Position::new(posl, source_lines),
            content: inner,
            markup: MarkupType::Math
        }
    }

pub FormattedText -> Element = StrongText
    / EmphText 
    / t:Template {t}
    / InlineMath
    / Reference
    / (posl:#position t:NormalText {t})


/* primitive terminals */

Emph = "''"
Strong = "'''"

Newline = "\n"
Equal = "="
TemplateOpen = "{{"
TemplateClose = "}}"
Space = " "
Quote = "\'"
Pipe = "|"
Fence = "#"
BeginMath = "<math>" / "<MATH>"
EndMath = "</math>" / "</MATH>"

Text<C> = posl:#position chars:C+ {
    let mut content = String::new();
    for c in chars {
        content.push_str(c);
    }
    Element::Text {
        position: Position::new(posl, source_lines),
        text: content
    }
}

Word -> String = #quiet<posl:#position chars:(!(Space) c:Char {c})+ {
    let mut content = String::new();
    for c in chars {
        content.push_str(c);
    }
    content
}> / #expected("url")

NormalText -> Element = #quiet<Text<Char>> / #expected("normal text")
MathText -> Element = #quiet<Text<MathChar>> / #expected("LaTeX source code")
TemplateAttributeName -> Element = #quiet<Text<TemplateChar>> / #expected("template attribute name")


MathChar -> &'input str = !(Newline / BeginMath / EndMath) c:$. {c}
Char -> &'input str = !(Newline / "=" / "'" / "{{" / "}}" / "|" / "[" / "]" / BeginMath / EndMath) c:$. {c}
TemplateChar -> &'input str = $([A-Za-z])



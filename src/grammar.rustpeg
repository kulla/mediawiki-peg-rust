use ast::*;

#![arguments(source_lines: &Vec<SourceLine>)]

/* the main document structure */

pub Document -> Element = posl:#position top:Paragraph* content:Heading* posr:#position {
    let mut res = top;
    let mut content = content;
    res.append(&mut content);
    
    Element::Document {
        position: Span::new(posl, posr, source_lines),
        content: res, 
    }
}

/* all paragraphs after a heading belong to its content */
HeadingParagraph -> Element = ParagraphTemplate<FormattedTextTemplate<Text<HeadingChar>>>
Heading -> Element = posl:#position d:$("="+) Space* caption:HeadingParagraph "="* pars:Paragraph* posr:#position {
        Element::Heading {
            position: Span::new(posl, posr, source_lines),
            depth: d.len(),
            caption: Box::new(caption),
            content: pars,
        }
    }

/* a paragraph is a block element, some or no text followed by a newline or just some text */
ParagraphTemplate<FormattedRule> = 
    List
    / Table
    / posl:#position PAR_START_GUARD text:((t:FormattedRule* Newline {t}) 
        / (f:FormattedRule+ Newline? {f})) posr:#position {
       
         Element::Paragraph {
            position: Span::new(posl, posr, source_lines),
            content: text,
        }
    } 

Paragraph -> Element = ParagraphTemplate<FormattedText>


/* mediawiki templates */
TemplateParagraph -> Element = ParagraphTemplate<FormattedTextTemplate<Text<TemplateContentChar>>>
Template -> Element = 
    posl:#position "{{" Space* n:TemplateName (Space / Newline)* attrs:("|" t:TemplateArgument {t})* "}}" posr:#position {
    Element::Template {
        position: Span::new(posl, posr, source_lines),
        name: n,
        content: attrs
    }
}

TemplateArgument -> Element = 
    posl:#position name:(n:TemplateArgumentName "=" {n})? value:TemplateParagraph+ posr:#position {
        Element::TemplateArgument {
            position: Span::new(posl, posr, source_lines),
            name: name.unwrap_or(String::new()),
            value: value,
        }    
    } 


/* mediawiki lists */
List -> Element = 
    posl:#position items:ListItem+ Space* Newline? posr:#position {
        Element::List {
            position: Span::new(posl, posr, source_lines),
            content: items,
        }
    }

ListItem -> Element = 
    Space* posl:#position s:($("*" / "#" / ":" / ";"))+ Space* content:FormattedText* Newline? posr:#position {
        let kind = match s[s.len() - 1] {
            "*" => ListItemKind::Unordered,
            "#" => ListItemKind::Ordered,
            ":" => ListItemKind::Definition,
            ";" => ListItemKind::DefinitionTerm,
            _ => ListItemKind::Unordered,
        };

        Element::ListItem {
            position: Span::new(posl, posr, source_lines),
            depth: s.len(),
            kind: kind,
            content: content,
        }
    }

/* mediawiki tables */
Table -> Element = 
    posl:#position "{|" attr:TableAttributeText? Newline (Space / Newline)* caption:TableCaption? rows:TableRow* "|}" posr:#position { 
        let (cap_attrs, cap_pars) = caption.unwrap_or((String::new(), vec![]));

        Element::Table {
            position: Span::new(posl, posr, source_lines),
            rows: rows,
            attributes: attr.unwrap_or(String::new()),
            caption: cap_pars,
            caption_attributes: cap_attrs,
        }
    }

TableParagraph -> Element = ParagraphTemplate<FormattedTextTemplate<Text<TableChar>>>
TableCaption -> (String, Vec<Element>) = "|+" attr:(t:TableAttributeText "|" {t})? Space* pars:TableParagraph* {(String::from(attr.unwrap_or(String::new()).trim()), pars)}
TableAttributeText -> String = attr:CharString<(!("|" / "!" / Newline) c:$. {c})> { String::from(attr.trim()) }
TableCellSeparator -> &'input str = $("||") / $("!!") / $("|") / $("!")
TableRowSeparator -> String = "|-"  attr:TableAttributeText? Newline { attr.unwrap_or(String::new()) }

TableRow -> Element =
    posl:#position !("|}") sep:TableRowSeparator? c:TableCell+ posr:#position {
        Element::TableRow {
            position: Span::new(posl, posr, source_lines),
            cells: c,
            attributes: sep.unwrap_or(String::new()),
        }
    }

TableCell -> Element = 
    posl:#position !("|}" / TableRowSeparator) sep:(TableCellSeparator) attr:(a:TableAttributeText 
    "|" !("|") {a})? Space* content:TableParagraph+ posr:#position {

        Element::TableCell {
            position: Span::new(posl, posr, source_lines),
            content: content,
            attributes: attr.unwrap_or(String::new()),
            header: sep.starts_with("!"),
        }
    }

/* internal references, may have pipe-separated options */
InternalReferenceFormatted -> Element = FormattedTextTemplate<Text<TemplateContentChar>>
ReferenceInternal -> Element =
    posl:#position "[[" t:((tar:InternalReferenceFormatted* {tar}) ++ "|") "]]" posr:#position {
        let mut t = t;
        Element::InternalReference {
            position: Span::new(posl, posr, source_lines),
            target: t.remove(0),
            caption: t.pop().unwrap_or(vec![]),
            options: t, 
        }      
    }

/* external references (hyperlink) with only url and optional caption */
ReferenceExternal -> Element = 
    posl:#position "[" url:Url Space* caption:FormattedText* "]" posr:#position {
        Element::ExternalReference {
            position: Span::new(posl, posr, source_lines),
            target: url,
            caption: caption
        }
    }

/* text markup */
StrongText -> Element =  
    posl:#position Strong inner:( !("'") t:FormattedText {t} / e:EmphText {e} )+ Strong posr:#position {
        Element::Formatted {
            position: Span::new(posl, posr, source_lines),
            content: inner,
            markup: MarkupType::Bold
        }
    }

EmphText -> Element =  
    posl:#position Emph inner:( !("'") t:FormattedText {t} / s:StrongText {s} )+ Emph posr:#position {
        Element::Formatted {
            position: Span::new(posl, posr, source_lines),
            content: inner,
            markup: MarkupType::Italic
        }
    }

InlineMath -> Element = inner:MarkupTag<"math"i, MathText*> {inner}
StrikeThroughMarkup -> Element = inner:MarkupTag<"del"i, (FormattedText / Paragraph)*> {inner}
    / inner:MarkupTag<"s"i, (FormattedText / Paragraph)*> {inner}

UnderlineMarkup -> Element = inner:MarkupTag<"ins"i, (FormattedText / Paragraph)*> {inner}
    / inner:MarkupTag<"u"i, (FormattedText / Paragraph)*> {inner}

NoWikiMarkup -> Element = inner:MarkupTag<"nowiki"i, NowikiText*> {inner}
CodeMarkup -> Element = inner:MarkupTag<"code"i, (FormattedText / Paragraph)*> {inner}
BlockquoteMarkup -> Element = inner:MarkupTag<"blockquote"i, (FormattedText / Paragraph)*> {inner}
PreformattedMarkup -> Element = inner:MarkupTag<"pre"i, PreformattedText*> {inner}

FormattedTextTemplate<TextRule> = formatted:(
    StrongText
    / EmphText 
    / Template
    / ReferenceInternal
    / ReferenceExternal
   
    / HtmlComment 
    / InlineMath
    / NoWikiMarkup
    / StrikeThroughMarkup
    / UnderlineMarkup
    / CodeMarkup
    / BlockquoteMarkup
    / PreformattedMarkup

    / AnyTag
    / TextRule
    ) {formatted}

FormattedText -> Element = f:FormattedTextTemplate<NormalText> {f}

/* html tags */
TagOpen<Name> = "<" Space* !("/") n:Name Space* attrs:(a:HtmlAttribute Space* {a})* ">" {(n, attrs)}
TagClose<Name> = "<" Space* "/" Space * Name Space* ">"
HtmlTag<Name, Inner> = o:TagOpen<Name> i:Inner TagClose<Name> {(o.0, o.1, i)}
HtmlAttribute -> TagAttribute = posl:#position key:TagName "=" value:(QuotedText / TagSafeLiteral) posr:#position {
    TagAttribute::new(Span::new(posl, posr, source_lines), key, value)
}

AnyOpen = TagOpen<TagName?> {()}
AnyClose = TagClose<TagName?> {()}

// matches any unknown html tag, creating a HtmlTag Element.
AnyTag -> Element = posl:#position t:HtmlTag<TagName, (FormattedText / Paragraph / Heading)*> posr:#position {
    Element::HtmlTag {
        position: Span::new(posl, posr, source_lines),
        name: String::from(t.0),
        attributes: t.1,
        content: t.2,
    }
}

HtmlComment -> Element = posl:#position "<!--" s:CharString<(!("-->") c:$. {c})>? "-->" posr:#position {
    Element::Comment {
        position: Span::new(posl, posr, source_lines),
        text: s.unwrap_or(String::new()),
    }
}

/* macro for simple formatting markup tags. Matches markup type by tag name (see ast.rs) */
MarkupTag<Name, Inner> = posl:#position tag_info:HtmlTag<$(Name), Inner> posr:#position { 
        Element::Formatted {
            position: Span::new(posl, posr, source_lines),
            content: tag_info.2,
            markup: get_markup_by_tag_name(tag_info.0),
        }
    }


/* primitive terminals */

Emph = "''"
Strong = "'''"

Space = " " / "\t"
Newline = "\n"

// a paragraph may not start with these symbols as they indicate other elements
PAR_START_GUARD = !("=" / "!" / "|" / "*" / "#" / ":" / ";")

Text<C> = 
    posl:#position s:CharString<C> posr:#position {
        Element::Text {
            position: Span::new(posl, posr, source_lines),
            text: s
        }
    }

CharString<C> = 
    chars:C+ {
        let mut result = String::new();;
        for c in chars {
            result.push_str(c);
        }
        result
    }

EnclosedLiteral<ClosingChar> = ClosingChar text:CharString<!(ClosingChar) c:$. {c}> ClosingChar {text}

/* primitive strings */
NormalText -> Element = #quiet<Text<Char>> / #expected("normal text")
MathText -> Element = #quiet<Text<MathChar>> / #expected("LaTeX source code")
TemplateArgumentName -> String = #quiet<CharString<TemplateAttributeNameChar>> / #expected("template attribute name")
NowikiText -> Element = #quiet<Text<(!(TagClose<"nowiki"i>) $(.))>> / #expected("any text")
PreformattedText -> Element = #quiet<Text<(!(TagClose<"pre"i>) $(.))>> / #expected ("any text")
TemplateName -> String = #quiet<CharString<TemplateNameChar>> / #expected("template name")
Url -> String =  #quiet<CharString<(!(Space / "]" / "|") c:$. {c})>> / #expected("a word of text (e.g. url)")
TagSafeLiteral -> String = #quiet<CharString<(!(Space / "<" / ">") c:$(.) {c})>> / #expected("tag attribute value")
QuotedText -> String = #quiet<EnclosedLiteral<"\""> / EnclosedLiteral<"'">> / #expected("quoted text")
TagName -> String = #quiet<CharString<!("<" / ">" / Space / "=") c:$. {c}>> / #expected("tag / attribute name")

/* character classes */
// These characters are allowed within certain contexts, other characters have special meaning and break texts
MathChar -> &'input str = !(TagClose<"math"i>) c:$. {c}
Char -> &'input str = !(Newline / Emph / "{" / "}" / AnyOpen / AnyClose / HtmlComment / "[" / "]") c:$. {c} // general inline context
HeadingChar -> &'input str = !(Newline / Emph / "{" / "}" / AnyOpen / AnyClose / HtmlComment / "[" / "]" / "=") c:$. {c}
TableChar -> &'input str = !(Newline / Emph / "{" / "}" / "!!" / AnyOpen / AnyClose / HtmlComment / "|" / "[" / "]") c:$. {c}
TemplateContentChar -> &'input str = !(Newline / Emph / "{" / "}" / AnyOpen / AnyClose / HtmlComment / "|" / "[" / "]") c:$. {c}
TemplateNameChar -> &'input str = !(Newline / "{{" / "}}" / "|") c:$. {c}
TemplateAttributeNameChar -> &'input str = $([A-Za-z0-9 ])

use ast::*;

#![arguments(source_lines: &Vec<SourceLine>)]


pub Document -> Element = posl:#position top:Paragraph* content:Heading* {
    let mut top = top;
    let mut content = content;
    let mut c = Vec::new(); 
    c.append(&mut top);
    c.append(&mut content);
    
    Element::Document {
        position: Position::new(posl, source_lines),
        content: c, 
    }
}

pub Heading -> Element = posl:#position d:$("="+) Space* caption:Paragraph pars:Paragraph*
    {
        Element::Heading {
            position: Position::new(posl, source_lines),
            depth: d.len(),
            caption: Box::new(caption),
            content: pars,
        }
    }


pub Paragraph -> Element = 
    List
    /
    posl:#position text:FormattedText* Newline {
        Element::Paragraph {
            position: Position::new(posl, source_lines),
            content: text,
        }
    }
    /
    /* end of file paragraph */
    posl:#position text:FormattedText+ EOF {
        Element::Paragraph {
            position: Position::new(posl, source_lines),
            content: text,
        }
    }
    

pub TemplateArgument -> Element = 
    posl:#position name:TemplateArgumentName "=" value:(Paragraph / FormattedText)+ {
        Element::TemplateArgument {
            position: Position::new(posl, source_lines),
            name: Box::new(Some(name)),
            value: value,
        }    
    } 
    /
    posl:#position value:(Paragraph / FormattedText)+ {
        Element::TemplateArgument {
            position: Position::new(posl, source_lines),
            name: Box::new(None),
            value: value,
        }
    }

pub Template -> Element = 
    posl:#position "{{" Space* s:TemplateArgument attrs:("|" t:TemplateArgument {t})* "}}" {
    let mut attrs = attrs;
    attrs.insert(0, s);
    Element::Template {
        position: Position::new(posl, source_lines),
        content: attrs
    }
}

List -> Element = 
    posl:#position items:ListItem+ Space* (Newline / EOF) {
        Element::List {
            position: Position::new(posl, source_lines),
            content: items,
        }
    }

ListItem -> Element = 
    posl:#position Space* s:($("*" / "#" / ":"))+ Space* content:FormattedText* (Newline / EOF) {
        let kind = match s[s.len() - 1] {
            "*" => ListItemKind::Unordered,
            "#" => ListItemKind::Ordered,
            ":" => ListItemKind::Definition,
            _ => ListItemKind::Unordered,
        };

        Element::ListItem {
            position: Position::new(posl, source_lines),
            depth: s.len(),
            kind: kind,
            content: content,
        }
    }

Reference -> Element = 
    posl:#position
    "[" url:Word Space? caption:FormattedText* "]" {
        Element::Reference {
            position: Position::new(posl, source_lines),
            target: url,
            caption: caption
        }
    }

StrongText -> Element =  
    posl:#position 
    Strong
    inner:( !("'") t:FormattedText {t} / e:EmphText {e} )+
    Strong {
        Element::Formatted {
            position: Position::new(posl, source_lines),
            content: inner,
            markup: MarkupType::Bold
        }
    }

EmphText -> Element =  
    posl:#position 
    Emph
    inner:( !("'") t:FormattedText {t} / s:StrongText {s} )+
    Emph {
        Element::Formatted {
            position: Position::new(posl, source_lines),
            content: inner,
            markup: MarkupType::Italic
        }
    }

InlineMath -> Element = 
    posl:#position
    BeginMath
    inner:MathText*
    EndMath {
        Element::Formatted {
            position: Position::new(posl, source_lines),
            content: inner,
            markup: MarkupType::Math
        }
    }

StrikeThroughMarkup -> Element = 
    posl:#position
    BeginStrikethrough
    inner:FormattedText+
    EndStrikethrough {
        Element::Formatted {
            position: Position::new(posl, source_lines),
            content: inner,
            markup: MarkupType::StrikeThrough
        }
    }

NoWikiMarkup -> Element = 
    posl:#position
    BeginNoWiki
    inner: NowikiText*
    EndNoWiki {
        Element::Formatted {
            position: Position::new(posl, source_lines),
            content: inner,
            markup: MarkupType::NoWiki
        }
    }

SingleQuoteText -> Element = posl:#position q:$("'") {
    Element::Text {
        position: Position::new(posl, source_lines),
        text: String::from(q),
    }
}


pub FormattedText -> Element = StrongText
    / EmphText 
    / t:Template {t}
    / InlineMath
    / Reference
    / NoWikiMarkup
    / StrikeThroughMarkup
    / (posl:#position t:NormalText {t})
    / SingleQuoteText


/* primitive terminals */

Emph = "''"
Strong = "'''"

EOF = !(".")
Space = " " / "\t"
Newline = "\n"
BeginMath = "<math>" / "<MATH>"
EndMath = "</math>" / "</MATH>"
BeginNoWiki = "<nowiki>" / "<NOWIKI>"
EndNoWiki = "</nowiki>" / "</NOWIKI>"
BeginStrikethrough = "<del>" / "<s>" / "<DEL>"
EndStrikethrough = "</del>" / "</s>" / "</DEL>"

Text<C> = 
    posl:#position chars:C+ {
        let mut content = String::new();
        for c in chars {
            content.push_str(c);
        }
        Element::Text {
            position: Position::new(posl, source_lines),
            text: content
        }
    }

Word -> String = #quiet<posl:#position chars:(!(Space) c:Char {c})+ {
    let mut content = String::new();
    for c in chars {
        content.push_str(c);
    }
    content
}> / #expected("url")

NormalText -> Element = #quiet<Text<Char>> / #expected("normal text")
MathText -> Element = #quiet<Text<MathChar>> / #expected("LaTeX source code")
TemplateArgumentName -> Element = #quiet<Text<TemplateChar>> / #expected("template attribute name")
NowikiText -> Element = #quiet<Text<(!(EndNoWiki) $(.))>> / #expected("any text.")

MathChar -> &'input str = !(Newline / BeginMath / EndMath) c:$. {c}
Char -> &'input str = !(Newline / "=" / "'" / "{{" / "}}" / "|" / "[" / "]" / BeginMath / EndMath / BeginNoWiki / EndNoWiki / BeginStrikethrough / EndStrikethrough) c:$. {c}
TemplateChar -> &'input str = $([A-Za-z0-9 ])


